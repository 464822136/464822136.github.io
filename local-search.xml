<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Linux权限认识</title>
    <link href="undefined2020/02/08/Linux%E6%9D%83%E9%99%90%E8%AE%A4%E8%AF%86/"/>
    <url>2020/02/08/Linux%E6%9D%83%E9%99%90%E8%AE%A4%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h3 id="1-文件类型"><a href="#1-文件类型" class="headerlink" title="1.文件类型"></a>1.文件类型</h3><p>Linux文件类型有五种：</p><p>普通文件、链接文件、字符文件、目录文件、块文件</p><p><img src="fileInfo.png" srcset="undefined" alt></p><p>上面是三种Linux文件格式其中不包含字符文件图片和块文件图片</p><p>每种文件有不同的表现方式</p><p>普通文件用一个-表示</p><p><img src="commonFile.png" srcset="undefined" alt></p><p>链接文件用l（link）表示</p><p><img src="linkFile.png" srcset="undefined" alt></p><p>字符文件用c 表示</p><p>目录文件用d（derectory）表示</p><p><img src="decretoryFile.png" srcset="undefined" alt></p><p>块文件用b（block） 表示</p><h3 id="2-文件权限"><a href="#2-文件权限" class="headerlink" title="2.文件权限"></a>2.文件权限</h3><p><img src="ls.png" srcset="undefined" alt></p><p>现在说一下文件格式后面的r w x分别是什么意思，但为什么会有这么多rwx呢？</p><p>因为linux是多用户操作系统所以每个文件都具备他自己或者其他用户的权限</p><p>然后就会有三组,每一组用三个-来表示权限：</p><p>1.第一组是文件所有者用户权限</p><p>2.第二组是文件所在组用户权限</p><p>3.第三组是文件其他组用户权限</p><p>r: 可读(4) w:可写(2) x:可执行(1)</p><p>括号里的数字也可以代表权限</p><p>紧跟在权限后面的是一个数字</p><p><img src="number.png" srcset="undefined" alt></p><p>这个数字根据文件类型来显示的</p><p>文件格式为目录的话它将会显示目录下有多少个子目录也会包括隐藏目录 . ..这两目录</p><p>. 表示当前目录  .. 表示上一级目录  通常用cd使用跳转</p><p>文件格式为文件的话显示文件硬链接数量</p><p><br></p><p><br></p><p><img src="myFileAndFileGroup.png" srcset="undefined" alt></p><p>数字后面接着的是文件所有者，后面再是文件所在组。</p><p>然后他们的后面又接着一个数字这个表示该文件大小</p><p>文件和目录显示有所不同</p><p>文件显示自己的字节大小</p><p><br></p><p>本文章根据尚硅谷韩顺平老师的Linux课程学习并撰写加深印象</p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringSecurity自定义资源认证</title>
    <link href="undefined2020/01/24/SpringSecurity%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B5%84%E6%BA%90%E8%AE%A4%E8%AF%81/"/>
    <url>2020/01/24/SpringSecurity%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B5%84%E6%BA%90%E8%AE%A4%E8%AF%81/</url>
    
    <content type="html"><![CDATA[<p>实现自定义资源认证步骤分为两步</p><h4>1.过滤器拦截</h4><p>​    1.1首先自定义一个类实现SpringSecurity提供的 FilterInvocationSecurityMetadataSource 接口重写三个方法</p><p>​    <img src="SecurityMetadataSource.png" srcset="undefined" alt></p><p>​    主要写第一个方法的逻辑就可以实现自定义的资源认证</p><p>​    <img src="getAttributes.png" srcset="undefined" alt></p><p>​    方法中的参数就是SpringSecurity封装了HttpServletRequest、HttpServletResponse、FilterChain的    一个类</p><p>​    <img src="FilterInvocation.png" srcset="undefined" alt></p><p>回到上面getAttributes方法</p><h4>1.2.1通过Request获取到请求的资源（地址）</h4><p>​        获取到请求的地址做什么？</p><p>​        这里这个方法的作用是将请求的资源所需要的权限返回去出去，需要用SpringSecurtiy提供的类封装好，</p><p>​        然后这个资源的需要的权限不一定只是一个所以是一个集合。</p><p>1.2.2通过请求的地址查询出需要的权限封装好并返回集合</p><p>​        下一步就是判断这个请求地址的权限在我们已认证的权限中有没有这个权限</p><h4>2.自定义权限决策器</h4><p>   SpringSecurity默认的决策器有三个分别是：</p><p>​    <img src="defaultDecide.jpg" srcset="undefined" alt></p><p>​    这里的票数应该是指权限的通过次数，比如访问个菜单或者按钮，他们需要三个权限，而登录的用户只有两个    权限那么就会有两票</p><p>​    因为我们是自定义决策器所以实现SpringSecurity提供的接口就好了</p><h4>AccessDecisionManager</h4><p></p><p>   也是三个方法</p><p>​    <img src="AccessDecisionManager.png" srcset="undefined" alt></p><p>主要写第一个方法的逻辑就好了，下面介绍了该方法的三个参数</p><p>Authentication var1: 封装了一些认证的信息</p><p>Object var2: 目前还没用到</p><p>Collection<configattribute> var3: 这参数是FilterInvocationSecurityMetadataSource 的getAttributes(Object o)返回过来的集合参数，也就是请求的地址所需要的权限用现在自定义决策器来验证该用户是否有权限</configattribute></p><p><img src="decide.png" srcset="undefined" alt></p><p>这里可根据自己的逻辑进行判断</p><p>接下来核心都写好了，但是还没指定用他们</p><p>在自定义类继承<strong>WebSecurityConfigurerAdapter</strong>的configure(HttpSecurity http)的方法中使用他们</p><p><img src="configure.png" srcset="undefined" alt></p><p>以上自定义资源认证来自个人理解，还请大佬们多多指教，不喜勿喷。</p>]]></content>
    
    
    
    <tags>
      
      <tag>SpringSecurity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>后端程序员必备知识(Linux)</title>
    <link href="undefined2019/10/27/%E5%90%8E%E7%AB%AF%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E5%A4%87%E7%9A%84Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>2019/10/27/%E5%90%8E%E7%AB%AF%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E5%A4%87%E7%9A%84Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<p>Linux因为是开源的,所以具有较高的安全性,现在几乎所有服务器都会安装在Linux上</p><a id="more"></a><h2 id="一-从认识操作系统开始"><a href="#一-从认识操作系统开始" class="headerlink" title="一 从认识操作系统开始"></a>一 从认识操作系统开始</h2><h3 id="1-1-操作系统简介"><a href="#1-1-操作系统简介" class="headerlink" title="1.1 操作系统简介"></a>1.1 操作系统简介</h3><p>我通过以下四点介绍什么操作系统：</p><ul><li><strong>操作系统（Operation System，简称OS）是管理计算机硬件与软件资源的程序，是计算机系统的内核与基石；</strong></li><li><strong>操作系统本质上是运行在计算机上的软件程序 ；</strong></li><li><strong>为用户提供一个与系统交互的操作界面 ；</strong></li><li><strong>操作系统分内核与外壳（我们可以把外壳理解成围绕着内核的应用程序，而内核就是能操作硬件的程序）。</strong></li></ul><p><img src="LinuxImg01.jpg" srcset="undefined" alt="操作系统分内核与外壳"></p><h3 id="1-2-操作系统简单分类"><a href="#1-2-操作系统简单分类" class="headerlink" title="1.2 操作系统简单分类"></a>1.2 操作系统简单分类</h3><ol><li><strong>Windows:</strong> 目前最流行的个人桌面操作系统 ，不做多的介绍，大家都清楚。</li><li><strong>Unix：</strong> 最早的多用户、多任务操作系统 .按照操作系统的分类，属于分时操作系统。Unix 大多被用在服务器、工作站，现在也有用在个人计算机上。它在创建互联网、计算机网络或客户端/服务器模型方面发挥着非常重要的作用。<br><img src="Unix.jpg" srcset="undefined" alt="Unix"></li><li><strong>Linux:</strong> Linux是一套免费使用和自由传播的类Unix操作系统.Linux存在着许多不同的Linux版本，但它们都使用了 <strong>Linux内核</strong> 。Linux可安装在各种计算机硬件设备中，比如手机、平板电脑、路由器、视频游戏控制台、台式计算机、大型机和超级计算机。严格来讲，Linux这个词本身只表示Linux内核，但实际上人们已经习惯了用Linux来形容整个基于Linux内核，并且使用GNU 工程各种工具和数据库的操作系统。</li></ol><p><img src="linux.png" srcset="undefined" alt="Linux"></p><h2 id="二-初探Linux"><a href="#二-初探Linux" class="headerlink" title="二 初探Linux"></a>二 初探Linux</h2><h3 id="2-1-Linux简介"><a href="#2-1-Linux简介" class="headerlink" title="2.1 Linux简介"></a>2.1 Linux简介</h3><p>我们上面已经介绍到了Linux，我们这里只强调三点。</p><ul><li><strong>类Unix系统：</strong> Linux是一种自由、开放源码的类似Unix的操作系统 </li><li><strong>Linux内核：</strong> 严格来说，Linux这个词本身只表示Linux内核 </li><li><strong>Linux之父：</strong> 一个编程领域的传奇式人物。他是Linux内核的最早作者，随后发起了这个开源项目，担任Linux内核的首要架构师与项目协调者，是当今世界最著名的电脑程序员、黑客之一。他还发起了Git这个开源项目，并为主要的开发者。</li></ul><p><img src="linux02.jpg" srcset="undefined" alt="Linux"></p><h3 id="2-2-Linux诞生简介"><a href="#2-2-Linux诞生简介" class="headerlink" title="2.2 Linux诞生简介"></a>2.2 Linux诞生简介</h3><ul><li>1991年，芬兰的业余计算机爱好者Linus Torvalds编写了一款类似Minix的系统（基于微内核架构的类Unix操作系统）被ftp管理员命名为Linux 加入到自由软件基金的GNU计划中; </li><li>Linux以一只可爱的企鹅作为标志，象征着敢作敢为、热爱生活。 </li></ul><h3 id="2-3-Linux的分类"><a href="#2-3-Linux的分类" class="headerlink" title="2.3 Linux的分类"></a>2.3 Linux的分类</h3><p><strong>Linux根据原生程度，分为两种：</strong></p><ol><li><strong>内核版本：</strong> Linux不是一个操作系统，严格来讲，Linux只是一个操作系统中的内核。内核是什么？内核建立了计算机软件与硬件之间通讯的平台，内核提供系统服务，比如文件管理、虚拟内存、设备I/O等；</li><li><strong>发行版本：</strong> 一些组织或公司在内核版基础上进行二次开发而重新发行的版本。Linux发行版本有很多种（ubuntu和CentOS用的都很多，初学建议选择CentOS），如下图所示：<br><img src="linux03.jpg" srcset="undefined" alt="Linux发行版本"></li></ol><h2 id="三-Linux文件系统概览"><a href="#三-Linux文件系统概览" class="headerlink" title="三 Linux文件系统概览"></a>三 Linux文件系统概览</h2><h3 id="3-1-Linux文件系统简介"><a href="#3-1-Linux文件系统简介" class="headerlink" title="3.1 Linux文件系统简介"></a>3.1 Linux文件系统简介</h3><p><strong>在Linux操作系统中，所有被操作系统管理的资源，例如网络接口卡、磁盘驱动器、打印机、输入输出设备、普通文件或是目录都被看作是一个文件。</strong></p><p>也就是说在LINUX系统中有一个重要的概念：<strong>一切都是文件</strong>。其实这是UNIX哲学的一个体现，而Linux是重写UNIX而来，所以这个概念也就传承了下来。在UNIX系统中，把一切资源都看作是文件，包括硬件设备。UNIX系统把每个硬件都看成是一个文件，通常称为设备文件，这样用户就可以用读写文件的方式实现对硬件的访问。</p><h3 id="3-2-文件类型与目录结构"><a href="#3-2-文件类型与目录结构" class="headerlink" title="3.2 文件类型与目录结构"></a>3.2 文件类型与目录结构</h3><p><strong>Linux支持5种文件类型 ：</strong><br><img src="linux04.jpg" srcset="undefined" alt="文件类型"></p><p><strong>Linux的目录结构如下：</strong></p><p>Linux文件系统的结构层次鲜明，就像一棵倒立的树，最顶层是其根目录：<br><img src="linux05.jpg" srcset="undefined" alt="Linux的目录结构"></p><p><strong>常见目录说明：</strong></p><ul><li><strong>/bin：</strong> 存放二进制可执行文件(ls、cat、mkdir等)，常用命令一般都在这里；</li><li><strong>/etc：</strong>  存放系统管理和配置文件；</li><li><strong>/home：</strong>  存放所有用户文件的根目录，是用户主目录的基点，比如用户user的主目录就是/home/user，可以用~user表示；</li><li><strong>/usr ：</strong> 用于存放系统应用程序；</li><li><strong>/opt：</strong> 额外安装的可选应用程序包所放置的位置。一般情况下，我们可以把tomcat等都安装到这里；</li><li><strong>/proc：</strong>  虚拟文件系统目录，是系统内存的映射。可直接访问这个目录来获取系统信息；</li><li><strong>/root：</strong>  超级用户（系统管理员）的主目录（特权阶级^o^）；</li><li><strong>/sbin:</strong>  存放二进制可执行文件，只有root才能访问。这里存放的是系统管理员使用的系统级别的管理命令和程序。如ifconfig等；</li><li><strong>/dev：</strong> 用于存放设备文件；</li><li><strong>/mnt：</strong> 系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他的文件系统；</li><li><strong>/boot：</strong>  存放用于系统引导时使用的各种文件；</li><li><strong>/lib ：</strong>      存放着和系统运行相关的库文件 ；</li><li><strong>/tmp：</strong> 用于存放各种临时文件，是公用的临时文件存储点；</li><li><strong>/var：</strong> 用于存放运行时需要改变数据的文件，也是某些大文件的溢出区，比方说各种服务的日志文件（系统启动日志等。）等；</li><li><strong>/lost+found：</strong>  这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows下叫什么.chk）就在这里。</li></ul><h2 id="四-Linux基本命令"><a href="#四-Linux基本命令" class="headerlink" title="四 Linux基本命令"></a>四 Linux基本命令</h2><p>下面只是给出了一些比较常用的命令。推荐一个Linux命令快查网站，非常不错，大家如果遗忘某些命令或者对某些命令不理解都可以在这里得到解决。</p><p>Linux命令大全：<a href="http://man.linuxde.net/" target="_blank" rel="noopener">http://man.linuxde.net/</a></p><h3 id="4-1-目录切换命令"><a href="#4-1-目录切换命令" class="headerlink" title="4.1 目录切换命令"></a>4.1 目录切换命令</h3><ul><li><strong><code>cd usr</code>：</strong>   切换到该目录下usr目录  </li><li><strong><code>cd ..（或cd../）</code>：</strong>  切换到上一层目录 </li><li><strong><code>cd /</code>：</strong>   切换到系统根目录  </li><li><strong><code>cd ~</code>：</strong>   切换到用户主目录 </li><li><strong><code>cd -</code>：</strong>   切换到上一个操作所在目录</li></ul><h3 id="4-2-目录的操作命令-增删改查"><a href="#4-2-目录的操作命令-增删改查" class="headerlink" title="4.2 目录的操作命令(增删改查)"></a>4.2 目录的操作命令(增删改查)</h3><ol><li><strong><code>mkdir 目录名称</code>：</strong> 增加目录</li><li><strong><code>ls或者ll</code></strong>（ll是ls -l的别名，ll命令可以看到该目录下的所有目录和文件的详细信息）：查看目录信息</li><li><p><strong><code>find 目录 参数</code>：</strong> 寻找目录（查）</p><p> 示例：</p><ul><li>列出当前目录及子目录下所有文件和文件夹: <code>find .</code></li><li>在<code>/home</code>目录下查找以.txt结尾的文件名:<code>find /home -name &quot;*.txt&quot;</code></li><li>同上，但忽略大小写: <code>find /home -iname &quot;*.txt&quot;</code></li><li>当前目录及子目录下查找所有以.txt和.pdf结尾的文件:<code>find . \( -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot; \)</code>或<code>find . -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot;</code></li></ul></li><li><p><strong><code>mv 目录名称 新目录名称</code>：</strong> 修改目录的名称（改）</p><p>注意：mv的语法不仅可以对目录进行重命名而且也可以对各种文件，压缩包等进行  重命名的操作。mv命令用来对文件或目录重新命名，或者将文件从一个目录移到另一个目录中。后面会介绍到mv命令的另一个用法。</p></li><li><p><strong><code>mv 目录名称 目录的新位置</code>：</strong>  移动目录的位置—剪切（改）</p><p> 注意：mv语法不仅可以对目录进行剪切操作，对文件和压缩包等都可执行剪切操作。另外mv与cp的结果不同，mv好像文件“搬家”，文件个数并未增加。而cp对文件进行复制，文件个数增加了。</p></li><li><p><strong><code>cp -r 目录名称 目录拷贝的目标位置</code>：</strong> 拷贝目录（改），-r代表递归拷贝 </p><p> 注意：cp命令不仅可以拷贝目录还可以拷贝文件，压缩包等，拷贝文件和压缩包时不  用写-r递归</p></li><li><p><strong><code>rm [-rf] 目录</code>:</strong> 删除目录（删）</p><p> 注意：rm不仅可以删除目录，也可以删除其他文件或压缩包，为了增强大家的记忆，  无论删除任何目录或文件，都直接使用<code>rm -rf</code> 目录/文件/压缩包</p></li></ol><h3 id="4-3-文件的操作命令-增删改查"><a href="#4-3-文件的操作命令-增删改查" class="headerlink" title="4.3 文件的操作命令(增删改查)"></a>4.3 文件的操作命令(增删改查)</h3><ol><li><strong><code>touch 文件名称</code>:</strong>  文件的创建（增）</li><li><p><strong><code>cat/more/less/tail 文件名称</code></strong> 文件的查看（查）</p><ul><li><strong><code>cat</code>：</strong> 查看显示文件内容</li><li><strong><code>more</code>：</strong> 可以显示百分比，回车可以向下一行， 空格可以向下一页，q可以退出查看</li><li><strong><code>less</code>：</strong> 可以使用键盘上的PgUp和PgDn向上 和向下翻页，q结束查看</li><li><strong><code>tail-10</code> ：</strong> 查看文件的后10行，Ctrl+C结束</li></ul><p>注意：命令 tail -f 文件 可以对某个文件进行动态监控，例如tomcat的日志文件，  会随着程序的运行，日志会变化，可以使用tail -f catalina-2016-11-11.log 监控 文 件的变化 </p></li><li><p><strong><code>vim 文件</code>：</strong>  修改文件的内容（改）</p><p>vim编辑器是Linux中的强大组件，是vi编辑器的加强版，vim编辑器的命令和快捷方式有很多，但此处不一一阐述，大家也无需研究的很透彻，使用vim编辑修改文件的方式基本会使用就可以了。</p><p><strong>在实际开发中，使用vim编辑器主要作用就是修改配置文件，下面是一般步骤：</strong></p><p> vim 文件——&gt;进入文件—–&gt;命令模式——&gt;按i进入编辑模式—–&gt;编辑文件  ——-&gt;按Esc进入底行模式—–&gt;输入：wq/q! （输入wq代表写入内容并退出，即保存；输入q!代表强制退出不保存。）</p></li><li><p><strong><code>rm -rf 文件</code>：</strong> 删除文件（删）</p><p> 同目录删除：熟记 <code>rm -rf</code> 文件 即可</p></li></ol><h3 id="4-4-压缩文件的操作命令"><a href="#4-4-压缩文件的操作命令" class="headerlink" title="4.4 压缩文件的操作命令"></a>4.4 压缩文件的操作命令</h3><p><strong>1）打包并压缩文件：</strong></p><p>Linux中的打包文件一般是以.tar结尾的，压缩的命令一般是以.gz结尾的。</p><p>而一般情况下打包和压缩是一起进行的，打包并压缩后的文件的后缀名一般.tar.gz。<br>命令：<strong><code>tar -zcvf 打包压缩后的文件名 要打包压缩的文件</code></strong><br>其中：</p><p>  z：调用gzip压缩命令进行压缩</p><p>  c：打包文件</p><p>  v：显示运行过程</p><p>  f：指定文件名</p><p>比如：加入test目录下有三个文件分别是：aaa.txt bbb.txt ccc.txt，如果我们要打包test目录并指定压缩后的压缩包名称为test.tar.gz可以使用命令：<strong><code>tar -zcvf test.tar.gz aaa.txt bbb.txt ccc.txt</code>或：<code>tar -zcvf test.tar.gz       /test/</code></strong></p><p><strong>2）解压压缩包：</strong></p><p>命令：tar [-xvf] 压缩文件</p><p>其中：x：代表解压</p><p>示例：</p><p>1 将/test下的test.tar.gz解压到当前目录下可以使用命令：<strong><code>tar -xvf test.tar.gz</code></strong></p><p>2 将/test下的test.tar.gz解压到根目录/usr下:<strong><code>tar -xvf xxx.tar.gz -C /usr</code></strong>（- C代表指定解压的位置）</p><h3 id="4-5-Linux的权限命令"><a href="#4-5-Linux的权限命令" class="headerlink" title="4.5 Linux的权限命令"></a>4.5 Linux的权限命令</h3><p> 操作系统中每个文件都拥有特定的权限、所属用户和所属组。权限是操作系统用来限制资源访问的机制，在Linux中权限一般分为读(readable)、写(writable)和执行(excutable)，分为三组。分别对应文件的属主(owner)，属组(group)和其他用户(other)，通过这样的机制来限制哪些用户、哪些组可以对特定的文件进行什么样的操作。通过 <strong><code>ls -l</code></strong> 命令我们可以  查看某个目录下的文件或目录的权限</p><p>示例：在随意某个目录下<code>ls -l</code></p><p><img src="linux06.jpg" srcset="undefined" alt></p><p>第一列的内容的信息解释如下：</p><p><img src="linux07.jpg" srcset="undefined" alt></p><blockquote><p>下面将详细讲解文件的类型、Linux中权限以及文件有所有者、所在组、其它组具体是什么？</p></blockquote><p><strong>文件的类型：</strong></p><ul><li>d： 代表目录</li><li>-： 代表文件</li><li>l： 代表软链接（可以认为是window中的快捷方式）</li></ul><p><strong>Linux中权限分为以下几种：</strong></p><ul><li>r：代表权限是可读，r也可以用数字4表示</li><li>w：代表权限是可写，w也可以用数字2表示</li><li>x：代表权限是可执行，x也可以用数字1表示</li></ul><p><strong>文件和目录权限的区别：</strong></p><p> 对文件和目录而言，读写执行表示不同的意义。</p><p> 对于文件：</p><table><thead><tr><th style="text-align:left">权限名称</th><th style="text-align:right">可执行操作</th></tr></thead><tbody><tr><td style="text-align:left">r</td><td style="text-align:right">可以使用cat查看文件的内容</td></tr><tr><td style="text-align:left">w</td><td style="text-align:right">可以修改文件的内容</td></tr><tr><td style="text-align:left">x</td><td style="text-align:right">可以将其运行为二进制文件</td></tr></tbody></table><p> 对于目录：</p><table><thead><tr><th style="text-align:left">权限名称</th><th style="text-align:right">可执行操作</th></tr></thead><tbody><tr><td style="text-align:left">r</td><td style="text-align:right">可以查看目录下列表</td></tr><tr><td style="text-align:left">w</td><td style="text-align:right">可以创建和删除目录下文件</td></tr><tr><td style="text-align:left">x</td><td style="text-align:right">可以使用cd进入目录</td></tr></tbody></table><p><strong>需要注意的是超级用户可以无视普通用户的权限，即使文件目录权限是000，依旧可以访问。</strong><br><strong>在linux中的每个用户必须属于一个组，不能独立于组外。在linux中每个文件有所有者、所在组、其它组的概念。</strong></p><ul><li><p><strong>所有者</strong></p><p>一般为文件的创建者，谁创建了该文件，就天然的成为该文件的所有者，用ls ‐ahl命令可以看到文件的所有者 也可以使用chown 用户名  文件名来修改文件的所有者 。</p></li><li><p><strong>文件所在组</strong></p><p>当某个用户创建了一个文件后，这个文件的所在组就是该用户所在的组 用ls ‐ahl命令可以看到文件的所有组 也可以使用chgrp  组名  文件名来修改文件所在的组。 </p></li><li><p><strong>其它组</strong></p><p>除开文件的所有者和所在组的用户外，系统的其它用户都是文件的其它组 </p></li></ul><blockquote><p>我们再来看看如何修改文件/目录的权限。</p></blockquote><p><strong>修改文件/目录的权限的命令：<code>chmod</code></strong></p><p>示例：修改/test下的aaa.txt的权限为属主有全部权限，属主所在的组有读写权限，<br>其他用户只有读的权限</p><p><strong><code>chmod u=rwx,g=rw,o=r aaa.txt</code></strong></p><p><img src="linux08.jpg" srcset="undefined" alt></p><p>上述示例还可以使用数字表示：</p><p>chmod 764 aaa.txt</p><p><strong>补充一个比较常用的东西:</strong></p><p>假如我们装了一个zookeeper，我们每次开机到要求其自动启动该怎么办？</p><ol><li>新建一个脚本zookeeper</li><li>为新建的脚本zookeeper添加可执行权限，命令是:<code>chmod +x zookeeper</code></li><li>把zookeeper这个脚本添加到开机启动项里面，命令是：<code>chkconfig --add  zookeeper</code></li><li>如果想看看是否添加成功，命令是：<code>chkconfig --list</code></li></ol><h3 id="4-6-Linux-用户管理"><a href="#4-6-Linux-用户管理" class="headerlink" title="4.6 Linux 用户管理"></a>4.6 Linux 用户管理</h3><p>Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。</p><p>用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。</p><p><strong>Linux用户管理相关命令:</strong></p><ul><li><code>useradd 选项 用户名</code>:添加用户账号</li><li><code>userdel 选项 用户名</code>:删除用户帐号</li><li><code>usermod 选项 用户名</code>:修改帐号</li><li><code>passwd 用户名</code>:更改或创建用户的密码</li><li><code>passwd -S 用户名</code> :显示用户账号密码信息</li><li><code>passwd -d 用户名</code>:  清除用户密码</li></ul><p>useradd命令用于Linux中创建的新的系统用户。useradd可用来建立用户帐号。帐号建好之后，再用passwd设定帐号的密码．而可用userdel删除帐号。使用useradd指令所建立的帐号，实际上是保存在/etc/passwd文本文件中。</p><p>passwd命令用于设置用户的认证信息，包括用户密码、密码过期时间等。系统管理者则能用它管理系统用户的密码。只有管理者可以指定用户名称，一般用户只能变更自己的密码。</p><h3 id="4-7-Linux系统用户组的管理"><a href="#4-7-Linux系统用户组的管理" class="headerlink" title="4.7 Linux系统用户组的管理"></a>4.7 Linux系统用户组的管理</h3><p>每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同Linux 系统对用户组的规定有所不同，如Linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。</p><p>用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对/etc/group文件的更新。</p><p><strong>Linux系统用户组的管理相关命令:</strong></p><ul><li><code>groupadd 选项 用户组</code> :增加一个新的用户组</li><li><code>groupdel 用户组</code>:要删除一个已有的用户组</li><li><code>groupmod 选项 用户组</code> : 修改用户组的属性</li></ul><h3 id="4-8-其他常用命令"><a href="#4-8-其他常用命令" class="headerlink" title="4.8 其他常用命令"></a>4.8 其他常用命令</h3><ul><li><strong><code>pwd</code>：</strong> 显示当前所在位置</li><li><strong><code>grep 要搜索的字符串 要搜索的文件 --color</code>：</strong> 搜索命令，–color代表高亮显示</li><li><p><strong><code>ps -ef</code>/<code>ps -aux</code>：</strong> 这两个命令都是查看当前系统正在运行进程，两者的区别是展示格式不同。如果想要查看特定的进程可以使用这样的格式：<strong><code>ps aux|grep redis</code></strong> （查看包括redis字符串的进程），也可使用 <code>pgrep redis -a</code>。</p><p>注意：如果直接用ps（（Process Status））命令，会显示所有进程的状态，通常结合grep命令查看某进程的状态。</p></li><li><p><strong><code>kill -9 进程的pid</code>：</strong> 杀死进程（-9 表示强制终止。）</p><p>先用ps查找进程，然后用kill杀掉</p></li><li><strong>网络通信命令：</strong><ul><li>查看当前系统的网卡信息：ifconfig</li><li>查看与某台机器的连接情况：ping </li><li>查看当前系统的端口使用：netstat -an</li></ul></li><li><strong>net-tools 和 iproute2 ：</strong><br> <code>net-tools</code>起源于BSD的TCP/IP工具箱，后来成为老版本Linux内核中配置网络功能的工具。但自2001年起，Linux社区已经对其停止维护。同时，一些Linux发行版比如Arch Linux和CentOS/RHEL 7则已经完全抛弃了net-tools，只支持<code>iproute2</code>。linux ip命令类似于ifconfig，但功能更强大，旨在替代它。更多详情请阅读<a href="https://linoxide.com/linux-command/use-ip-command-linux" target="_blank" rel="noopener">如何在Linux中使用IP命令和示例</a></li><li><strong><code>shutdown</code>：</strong>  <code>shutdown -h now</code>： 指定现在立即关机；<code>shutdown +5 &quot;System will shutdown after 5 minutes&quot;</code>：指定5分钟后关机，同时送出警告信息给登入用户。</li><li><strong><code>reboot</code>：</strong>  <strong><code>reboot</code>：</strong>  重开机。<strong><code>reboot -w</code>：</strong> 做个重开机的模拟（只有纪录并不会真的重开机）。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>超详细CentOs7下安装redis以及搭建集群(排坑)</title>
    <link href="undefined2019/10/01/%E8%B6%85%E8%AF%A6%E7%BB%86CentOS7%E4%B8%8B%E5%AE%89%E8%A3%85redis%E4%BB%A5%E5%8F%8A%E6%90%AD%E5%BB%BA%E9%9B%86%E7%BE%A4-%E6%8E%92%E5%9D%91/"/>
    <url>2019/10/01/%E8%B6%85%E8%AF%A6%E7%BB%86CentOS7%E4%B8%8B%E5%AE%89%E8%A3%85redis%E4%BB%A5%E5%8F%8A%E6%90%AD%E5%BB%BA%E9%9B%86%E7%BE%A4-%E6%8E%92%E5%9D%91/</url>
    
    <content type="html"><![CDATA[<p>本章会带大家手把手在CentOS7环境下搭建Redis,并且带你一一排坑</p><a id="more"></a><h3 id="一-安装CentOS7"><a href="#一-安装CentOS7" class="headerlink" title="一.安装CentOS7"></a>一.安装CentOS7</h3><p><strong>1.下载VMware</strong></p><p><strong>2.下载CentOS 7镜像</strong></p><p><strong>3.在虚拟机上安装CentOS 7</strong></p><p>选择创建虚拟机</p><p><img src="redisImg06.png" srcset="undefined" style="zoom:60%;"></p><p><em>选择自定义</em></p><p><img src="redisImg03.png" srcset="undefined" style="zoom:80%;"></p><p>这里看你下载的VMware是什么版本,我下载的是15X所以我选择15.X</p><p><img src="redisImg05.png" srcset="undefined" style="zoom:80%;"></p><p>选择稍后安装操作系统</p><p><img src="redisImg01.png" srcset="undefined" style="zoom:80%;"></p><p>随后点下一步,这里操作系统选择Linux,版本选择CentOS7</p><p><img src="redisImg02.png" srcset="undefined" style="zoom:80%;"></p><p>安装位置改不改看你自己</p><p><img src="redisImg07.png" srcset="undefined" style="zoom:67%;"></p><p>这里处理器数量根据自己CPU情况来定</p><p><img src="redisImg08.png" srcset="undefined" style="zoom:67%;"></p><p>运行内存默认为1G，这里因为我是8G运行内存所以我选择2G,根据自己机器情况来定</p><p><img src="redisImg09.png" srcset="undefined" style="zoom:67%;"></p><p>网络类型这里我们选择桥连接,桥连接也就是直接用我们主机上的网络,并不是Linux重新建立网络连接</p><p><img src="redisImg10.png" srcset="undefined" style="zoom:67%;"></p><p>接下来的两步默认即可,然后选择创建新虚拟磁盘</p><p><img src="redisImg11.png" srcset="undefined" style="zoom:67%;"></p><p>默认大小20G,可以先不改,后续需要可以再加,选择将虚拟磁盘拆分成多个文件</p><p><img src="redisImg12.png" srcset="undefined" style="zoom:67%;"></p><p>然后一直点下一步最后虚拟机创建完成</p><p>打开虚拟机设置,因为我们在上面选择了稍后安装操作系统,所以我们现在需要选择CentOS7的镜像</p><p>选择CD/DVD(IDE) 在右侧单击预览找到我们在第一步下载的CentOs7镜像文件</p><p><img src="redisImg13.png" srcset="undefined" style="zoom:67%;"></p><p>安装好后运行虚拟机，直接选择第一个安装CentOS7,如果选择第二个的话会选检测你的环境,可能会出现一些没必要的报错</p><p><img src="redisImg14.png" srcset="undefined" style="zoom:67%;"></p><p>选择第一个后等待它安装,如果没出意外安装好后会出现界面</p><p><img src="redisImg15.png" srcset="undefined" style="zoom:67%;"></p><p>语言我们选择简体中文,点击下一步后进入安装信息界面,如果出现这种黄色感叹号,只要我们点进去然后再点左上角完成就没事了</p><p><img src="redisImg16.png" srcset="undefined" style="zoom:67%;"></p><p><img src="redisImg17.png" srcset="undefined" style="zoom:67%;"></p><p>然后点击开始安装,在安装的时候可以设置Root密码,否则用默认的不怎么舒服</p><p><img src="redisImg18.png" srcset="undefined" style="zoom:67%;"></p><p>等待它安装,安装好后重启</p><h3 id="二-安装redis"><a href="#二-安装redis" class="headerlink" title="二.安装redis"></a>二.安装redis</h3><p><strong>1.准备工作</strong></p><h4 id="第一步-首先安装gcc依赖"><a href="#第一步-首先安装gcc依赖" class="headerlink" title="第一步:首先安装gcc依赖"></a>第一步:首先安装gcc依赖</h4><pre><code>yum install gcc</code></pre><h4 id="第二步-下载redis安装包"><a href="#第二步-下载redis安装包" class="headerlink" title="第二步:下载redis安装包"></a>第二步:下载redis安装包</h4><p>这步记得先进目录再下载介意进到 usr/local 目录下安装,这里注意一下,如果这种方式安装不了那就进到redis官网下载安装包,然后使用Xftp上传到Linux</p><pre><code>wget http://download.redis.io/releases/redis-5.0.4.tar.gz</code></pre><h4 id="第三步-解压压缩包"><a href="#第三步-解压压缩包" class="headerlink" title="第三步: 解压压缩包"></a>第三步: 解压压缩包</h4><pre><code>tar -zxvf redis-5.0.4.tar.gz </code></pre><p>为了后续操作方便也可以将文件名改名</p><pre><code>mv redis-5.0.4 redis</code></pre><h4 id="第五步：编译redis"><a href="#第五步：编译redis" class="headerlink" title="第五步：编译redis"></a>第五步：编译redis</h4><pre><code>cd /usr/local/redis/</code></pre><pre><code> make MALLOC=libc</code></pre><h4 id="第六步：安装redis到bin目录"><a href="#第六步：安装redis到bin目录" class="headerlink" title="第六步：安装redis到bin目录"></a>第六步：安装redis到bin目录</h4><pre><code>cd /usr/local/redis/src</code></pre><pre><code>make install</code></pre><h4 id="第七步：测试是否安装成功"><a href="#第七步：测试是否安装成功" class="headerlink" title="第七步：测试是否安装成功"></a>第七步：测试是否安装成功</h4><p>进入到/usr/local/redis/src目录执行启动服务</p><pre><code>./redis-server</code></pre><p>出现如下界面说明安装成功了！</p><p><img src="redisImg19.png" srcset="undefined" style="zoom:80%;"></p><p>这个时候因为我们不能后台运行,所以会一直在这个界面,先按Ctrl+C退出</p><h4 id="第八步：配置redis后台运行"><a href="#第八步：配置redis后台运行" class="headerlink" title="第八步：配置redis后台运行"></a>第八步：配置redis后台运行</h4><p>进入到/usr/local/redis/目录,打开redis.conf文件</p><p><code>vi redis.conf</code></p><p>按/打开搜索，然后搜索 daemonize按 i 编辑将daemonize后面的no改成yes,改好后按Esc退出编辑,按住Ctrl+/然后输入wq保存退出.</p><p>这个时候我们的后台运行配置就完成了！</p><p>再次回到/usr/local/redis/src目录，不过这次运行redis有所不同,这次我们得指定配置文件运行</p><p><code>./redis-server /usr/local/redis/redis.conf</code></p><p>指定我们刚刚配置的配置文件运行，这样我们就能后台运行了！</p><h4 id="第九步：配置远程连接"><a href="#第九步：配置远程连接" class="headerlink" title="第九步：配置远程连接"></a>第九步：配置远程连接</h4><p>因为redis默认只能本地连接数据库,想要在其他计算机比如我们的主计算机windows上运行的话得更改运行其他IP连接</p><p>再次打开redis.conf,按照上面教你们的方法搜索bind 127.0.0.1,然后将127.0.0.1更改为0.0.0.0或者在前面加个#号注释掉也行</p><p>redis单机版的安装基本到这就完成了,再提一下,如果想要停止redis服务,执行如下命令</p><p><code>./redis-cli  shutdown</code></p><h2 id="三-搭建集群"><a href="#三-搭建集群" class="headerlink" title="三.搭建集群"></a>三.搭建集群</h2><h4 id="第一步：准备6份redis"><a href="#第一步：准备6份redis" class="headerlink" title="第一步：准备6份redis"></a>第一步：准备6份redis</h4><p>在/usr/local/目录下创建redis-cluster文件夹用于存放redis文件夹</p><p>将redis文件夹复制到redis-cluster中,复制6份</p><p>找到我们编译好的bin文件夹,如果是按照我的步骤来的话bin文件夹应该是在/usr/local/bin，这个目录,然后创将bin文件夹下所有文件复制到redis-cluter中，复制六份</p><pre><code>cp -r bin redis-cluster/redis01cp -r bin redis-cluster/redis02cp -r bin redis-cluster/redis03cp -r bin redis-cluster/redis04cp -r bin redis-cluster/redis05cp -r bin redis-cluster/redis06</code></pre><p>复制好之后进到redis目录下,将redis.conf文件拷贝到我们刚刚创建的六个文件夹(redis1~6)，如果有 <code>dump.rdb</code> 这个文件的话删掉这个文件 <code>rm -f dump.rdb</code> </p><p>这些做完之后我们进入到redis01文件夹,编辑redis.conf文件<code>vi redis.conf</code></p><p>首先将这个文件的cluster中的cluster-enable yes将它的注释解开,只有这样它才能支持集群</p><p><img src="redisImg20.png" srcset="undefined" style="zoom:67%;"></p><p>然后找到port 6379，将它改成9624,然后其他五个文件夹重复以上操作,分别改成9624~9629</p><p><img src="redisImg21.png" srcset="undefined" style="zoom:67%;"></p><h4 id="第二步：启动redis集群"><a href="#第二步：启动redis集群" class="headerlink" title="第二步：启动redis集群"></a>第二步：启动redis集群</h4><p>经过不懈努力我们终于到最重要的一步了,因为启动集群需要重复六次几乎相同的操作,所以在这做成脚本,否则以后我们每次启动都要重复六次相同的操作有点累人.</p><p>进到集群目录,/usr/local/redis-cluster,在目录下直接编辑脚本<code>vi start-cluster</code></p><pre><code class="bash">cd redis01./redis-server redis.confcd ..cd redis02./redis-server redis.confcd ..cd redis03./redis-server redis.confcd ..cd redis04./redis-server redis.confcd ..cd redis05./redis-server redis.confcd ..cd redis06./redis-server redis.confcd ..</code></pre><p>将以上内容编辑到创建的文件中,可以先写一条,然后再按v选中写好的一条,再按y复制,然后换行再按p粘贴,重复五次就好了(记得改redis后面的数字,01~06),写好之后保存退出</p><p>然后ls查看是不是多了一个start-cluster的文件,但是这个时候是灰色的</p><p><img src="redisImg22.png" srcset="undefined" style="zoom:80%;"></p><p>我们得给它权限,让它变成可执行文件,执行<code>chmod u+x start-cluster.sh</code></p><p>这个时候再看,是不是变成绿色了，现在我们直接执行脚本，<code>./start-cluster.sh</code></p><p>执行完后查看是否启动成功,执行<code>ps aux|grep redis</code> </p><p><img src="redisImg23.png" srcset="undefined" style="zoom:80%;"></p><h4 id="第三步：分配槽"><a href="#第三步：分配槽" class="headerlink" title="第三步：分配槽"></a>第三步：分配槽</h4><p>到这一步就几乎已经装好了,只要创建集群然后让它自动分配槽就行了</p><p>执行如下命令</p><pre><code class="undefined">./redis-cli --cluster create 127.0.0.1:9624 127.0.0.1:9625 127.0.0.1:9626 127.0.0.1:9627 127.0.0.1:9628 127.0.0.1:9629 --cluster-replicas 1</code></pre><p>后面的1表示有一台备份机器,执行完后输入yes然后就行了</p><p><img src="redisImg24.png" srcset="undefined" style="zoom:80%;"></p><h3 id="终于把redis集群搭好了-感谢您耐心的看到这里-谢谢！"><a href="#终于把redis集群搭好了-感谢您耐心的看到这里-谢谢！" class="headerlink" title="终于把redis集群搭好了,感谢您耐心的看到这里,谢谢！"></a>终于把redis集群搭好了,感谢您耐心的看到这里,谢谢！</h3>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>深入了解HashMap容量为什么是2的幂次方</title>
    <link href="undefined2019/08/28/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3HashMap%E5%AE%B9%E9%87%8F%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF2%E7%9A%84%E5%B9%82%E6%AC%A1%E6%96%B9/"/>
    <url>2019/08/28/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3HashMap%E5%AE%B9%E9%87%8F%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF2%E7%9A%84%E5%B9%82%E6%AC%A1%E6%96%B9/</url>
    
    <content type="html"><![CDATA[<p>本章通过Java源码通俗易懂的解释了为什么HashMap的初始容量为2的n次幂时效率最高</p><a id="more"></a><h3 id="一-HashMap的数据结构"><a href="#一-HashMap的数据结构" class="headerlink" title="一.HashMap的数据结构"></a>一.HashMap的数据结构</h3><p>首先要解读HashMap的源码,那么首先得知道它的数据结构,在JDK1.8之前HashMap的数据结构是数组+链表实现的,但是在JDK1.8后为了防止链表长度太长引起各种问题后,所以链表中的数量到达阈值的时候会转为红黑树<strong>(默认阈值是8)</strong> ，具体可以看下面源码</p><pre><code class="java">/** * The load factor used when none specified in constructor. */static final float DEFAULT_LOAD_FACTOR = 0.75f;/** * The bin count threshold for using a tree rather than list for a * bin.  Bins are converted to trees when adding an element to a * bin with at least this many nodes. The value must be greater * than 2 and should be at least 8 to mesh with assumptions in * tree removal about conversion back to plain bins upon * shrinkage. */static final int TREEIFY_THRESHOLD = 8;</code></pre><h3 id="二-Hash算法"><a href="#二-Hash算法" class="headerlink" title="二.Hash算法"></a>二.Hash算法</h3><p>通过上面我们可以知道HashMap是通过数组+链表存储数据的,那么HashMap又是如何来计算元素的位置呢</p><p> 我们可以看到在HashMap中要找到某个元素，需要根据Key的<strong>Hash值</strong>来求得对应数组中的位置。如何计算这个位置就是<strong>Hash算法</strong>。前面说过HashMap的数据结构是数组+链表 ,那么我们肯定希望链表里的元素少一点,因为每往链表里添加一个元素就意味着Hash算法得出来的值相同了,也就是所谓的Hash碰撞,所以我们希望HashMap元素的位置尽量分布均匀一点,尽量的每个位置上的元素只有一个,这样的话我们使用Key得到元素的位置的时候就不需要再去遍历链表了。</p><p>所以我们首先想到的是对Hash值进行取模运算,这样的话分布也还算均匀,但是我们都知道取模运算效率并不高,那么我们来看看Java到底是怎么做的</p><p><strong>我会分别给大家看一下JDK1.7和JDK1.8中的hash算法</strong></p><h4 id="1-JDK1-7中的hash算法"><a href="#1-JDK1-7中的hash算法" class="headerlink" title="1.JDK1.7中的hash算法"></a>1.JDK1.7中的hash算法</h4><p>首先是JDK1.7中的Hash算法</p><pre><code class="java">static int indexFor(int h, int length) {    return h &amp; (length-1); }</code></pre><p>从上面代码中我们可以看见,Java在JDK1.7的时候是先将<strong>Hash值与数组长度-1进行一个与运算</strong>,虽然代码只有一行,但是这就是高手写代码(一行搞定)开个玩笑,不过JDK1.8的HashMap作者也不知道是谁,事了拂衣去，深藏身与名嘛</p><p>那么这行代码到底干了什么事呢,在说它干了什么事之前我们要先知道与运算到底是个什么东西,如果懂的朋友可以跳过这段</p><p>我们都知道计算机中0代表无1代表有,也就是说0代表false/1代表了true,如果知道这一点那么就容易了,说白了与运算就是对二进制进行并且判断,如果两个有一个为0那么返回0如果两个都为1则返回1,比如</p><p><code>4&amp;7</code> </p><pre><code class="java">00000100 与 00000111 </code></pre><p>综上所述,它们结果就是 <code>00000100</code> 所以还是4,大家都懂与运算是干什么了吧</p><p>那么为什么说只有HashMap 的初始容量为2的幂次方时效率才最高呢,通俗易懂的说就是,二进制的计算规则是只要往左移一位相当于2^n+1<strong>注意:n是从0开始的,也就是如果第一位是1那么就是2^0也就是等于1</strong>,比如00000001如果往左移一位00000010也就是2^1等于2,明白了这个之后我们可以看出如果说我们的长度不是2的n次方,那么长度-1也就变成了偶数,如果是偶数的话,我们是不是第一位也就永远不可能为1呢,所以当进行与运算的时候就增加了碰撞的几率,hash碰撞的几率增加了那么我们在拿值的时候就需要遍历链表,这样一来效率就极大的降低了,并且数组中有些位置永远用不到,还浪费了空间。</p><p><strong>最后总结一下, 当数组长度为2的n次幂的时候，不同的key算得得index相同的几率较小，那么数据在数组上分布就比较均匀，也就是说碰撞的几率小，相对的，查询的时候就不用遍历某个位置上的链表，这样查询效率也就较高了。  </strong></p><h4 id="2-JDK1-8中的hash算法"><a href="#2-JDK1-8中的hash算法" class="headerlink" title="2.JDK1.8中的hash算法"></a>2.JDK1.8中的hash算法</h4><p>首先我们看看Java源码是怎么写的</p><pre><code class="java">/**     * Computes key.hashCode() and spreads (XORs) higher bits of hash     * to lower.  Because the table uses power-of-two masking, sets of     * hashes that vary only in bits above the current mask will     * always collide. (Among known examples are sets of Float keys     * holding consecutive whole numbers in small tables.)  So we     * apply a transform that spreads the impact of higher bits     * downward. There is a tradeoff between speed, utility, and     * quality of bit-spreading. Because many common sets of hashes     * are already reasonably distributed (so don&#39;t benefit from     * spreading), and because we use trees to handle large sets of     * collisions in bins, we just XOR some shifted bits in the     * cheapest possible way to reduce systematic lossage, as well as     * to incorporate impact of the highest bits that would otherwise     * never be used in index calculations because of table bounds.     */    static final int hash(Object key) {        int h;        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);    }</code></pre><p>（1）首先获取对象的hashCode()值，然后将hashCode值右移16位，然后将右移后的值与原来的hashCode做<strong>异或</strong>运算，返回结果。（其中h&gt;&gt;&gt;16，在JDK1.8中，优化了高位运算的算法，使用了零扩展，无论正数还是负数，都在高位插入0）。</p><p>（2）在putVal源码中，我们通过(n-1)&amp;hash获取该对象的键在hashmap中的位置。（其中hash的值就是（1）中获得的值）其中n表示的是hash桶数组的长度，并且该长度为2的n次方，这样(n-1)&amp;hash就等价于hash%n。因为&amp;运算的效率高于%运算。</p><p><strong>所以在JDK1.8中代码虽然与JDK1.7中的代码不一样,但是原理还是相同的</strong></p><p><strong>感谢您耐心的看完~</strong></p>]]></content>
    
    
    <categories>
      
      <category>深入了解Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第一篇内容</title>
    <link href="undefined2019/05/28/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%86%85%E5%AE%B9/"/>
    <url>2019/05/28/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%86%85%E5%AE%B9/</url>
    
    <content type="html"><![CDATA[<p>第一个博客，经过三番五次的安装，终于配的像个样子了。然后步入正题</p><p>1、使用 git clone 主题连接 放到 themes/主题名 然后把 _config.yml的theme改成下载的主题名    </p><p>2、到github下载主题下载完成后解压到themes之后也把 _config.yml themes改成下载好的名字</p>]]></content>
    
    
    <categories>
      
      <category>初尝</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>